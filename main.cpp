#include <iostream>
#include "SeqList.h"

/**********************************************************************************************************/

/** 插入操作。插入操作就是在顺序表 L 中的第i个位置插入新的元素e，
 * 使顺序表 { A1,A2,A3,・・・,Ai-1,Ai,・・・,An }
 * 变成   { A1,A2,A3,・・・,Ai-1, e ,Ai,・・・,An }
 * 顺序表的长度也由 n变为 n+1
 * */

/**   算法思想：要在顺序表中的第i个位置上插入元素 e，首先需将表中位置为 n，n-1,・・・,i上的元素一次往后移一个位置，将第i个位置空出
 *    然后将该位置插入新元素 e。当 i=n+1时，是指在顺序表的末尾插入元素，无需移动元素，直接将 e插入表的末尾即可
 *
 *        例如，顺序表   { 3，15，49，20，23，44，18，36 } 的第 5个元素之前插入一个元素 22
 *    需要为 36,18,44,23 依次往后移动一个位置，然后再在第 5号位置插入元素 22
 *    顺序表变成     { 3，15，49，20，22，23，44，18，36 }
 * */

/** 在顺序表的第i个位置插入元素 e */
int InsertList(SeqList *L, int i, DataType e) {
    if (i < 1 || i > L->length + 1)         //再插入元素之前，判断插入位置是否合法
    {
        printf("插入位置i不合法\n");
        return -1;
    } else if (L->length >= ListSize)   //在插入元素前，判断元素表是否已满
    {
        printf("顺序表已经满了，不能在插入新的元素\n");
        return 0;
    } else {
        for (int j = L->length; j >= i; --j)    //将第i个位置以后的元素依次后移
        {
            L->list[j] = L->list[j - 1];    //数组中的值依次往后移动
            L->list[i - 1] = e;             //插入元素到第i个位置
            L->length = L->length + 1;      //顺序表长度增加1
            return 1;
        }
    }
}

/** 在执行插入操作时，插入元素的位置i的合法范围是 1 ≤ i ≤ L-> length+1 当 i = 1 时，插入位置时在第一个元素之前，对应 C语言数组
 * 中的第 0个元素；当 i=L->length+1 时，最后一个元素之后，对应 C语言数组中最后一个元素之后的位置。当插入位置是 i=L->length+1 时
 * 不需要移动元素；当插入位置是i=0时，则需要移动所有元素。
 *
 *  PS：插入时判断插入位置是否合法，还有存储空间是否已满，插入后要将表长增加 1
 * */


/*********************************************************************************************/

/** 删除操作:删除操作就是将顺序表 L 中第 i个位置的元素删除，
 * 使顺序表 { A1,A2,・・・,Ai-1,Ai,Ai+1,・・・,An }
 * 变成 { A1,A2,・・・,Ai-1,Ai+1,・・・,An }
 * 顺序表的长度也由 n 变成 n-1
 * */

/** 算法思想：为了删除顺序表中的第 i个元素，需要将第 i+1个位置之后的元素一次向前移动一个位置，即先将第 i+1个元素移动到第 i个位置
 * 再将第 i+2个元素移动到第 i+1个位置，依次类推，直到最后一个元素移动到倒数第二个位置。最后将顺序表的长度 减 1
 *
 *      例如：删除顺序表 { 3,15,49,20,22,23,44,18,36 }的第4个元素，需要将序号为 5,6,7,8,9的元素依次向前移动一个位置，这样
 *      就删除了第4个元素，最后将表长 减 1
 * */

/** 删除元素表的第 i个位置上的元素 */
int DeleteList(SeqList *L, int i, DataType *e) {
    if (L->length <= 0) {                           //判断顺序表是是否为空
        printf("顺序表已空不能进行删除\n");
        return 0;
    } else if (i < 1 || i > L->length) {        //判断删除位置是否合理
        printf("删除位置不合适\n");
        return -1;
    } else {
        *e = L->list[i - 1];        //将要删除的元素给 *e
        for (int j = i; j <= L->length - 1; ++j) {      //数组中的元素依次往前移动，直到覆盖掉需要删除指定位置的值
            L->list[j - 1] = L->list[j];            //将数组元素的值往前移动，数组下标的值相比于未删除的下标值 减1
            L->length = L->length - 1;          //数组长度减1
            return 1;
        }
    }
}

/** 删除元素的位置 i的合法范围在 1 ≤ i ≤ L->length 。当 i=1时，表示删除第一个元素，（对应的数组下标为0的元素）；
 * 当 i=L->length 时，表示删除的时最后一个元素。
 *
 * PS：删除元素要看表中是否还有元素，删除位置是否合法。删除后，顺序表的长度要 减 1
 * */

/** 求顺序表的长度 */
int ListLength(SeqList L) {
    return L.length;
}

/** 清空顺序表 */
void ClearList(SeqList *L) {
    L->length = 0;
}
